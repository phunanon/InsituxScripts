(var cmds "Examples: \"heal XxPlayerxX\" or \"heal Xx\"
  \"team security\" or \"team insurgent\" - switch to either team
  \"heal\" or \"heal [player]\" - heal you or a player fully
  \"drone\" or \"drone [player]\" - drone strike on your or player
  \"brrr [player]\" - airstrike on player
  \"flare\" or \"flare [player]\" - fire a flare above yourself or player
  \"boom [player]\" - kill player with an explosion
  \"boom near [player]\" - explosion near the player (non-lethal)
  \"tp [player] here\" or \"tp to [player]\" or \"tp [player1] to [player2]\"
  \"plant\" - plant claymore where you stand")

(function rand-circle-point position radius
  (var r radius)
  (-> (rand (* 2 PI))
      (fn a [(cos a) 0 (sin a)])
      (map (* r))
     @(map + position)))

(function n. name
  (var n name)
  (print "n." n)
  (find (fn p (.. starts? (map lower-case [n p])))
        (dl.list_players)))

(function grenade pos
  (print pos)
  (dl.util.explosion pos "TestGrenade"))

(function plr who key val
  (let prop (match key :pos "position" :team "team" :hp "health")
       prop (str "$dl.players." who "." prop))
  (if (= key :alive?)
      (return ((str "dl.players." who ".is_alive"))))
  (catch
    (if val
      (do (prop val) :success)
      (eval prop))
    (print "plr errors: " errors)))

(function monologue messages delay
  (var d (or delay 1))
  (map (fn msg (dl.util.fmessage msg)
               (wait d))
       messages))

(function players
  (-> (dl.list_players)
      (map (fn who (str (plr who :team) ": " who)))
      (fn players (monologue players .2))))

(function teleport from to
(print "teleport " from " to " to)
  (let pos (plr to :pos))
  (if! pos (return))
  (if (plr from :pos pos)
      (str from " teleported to " to)))

(function heal who
  (if (plr who :hp 100)
      (str "Healed " who)))

(function team who team-name
  (let name ((starts? "i" team-name) "insurgent" "security"))
  (if (plr who :team name)
      (str who " now " name)))

(function boom who is-near
  (let pos (plr who :pos))
  (if! pos (return))
  (-> (is-near (rand-circle-point pos 48) pos)
     #(dl.util.explosion % "TestGrenade"))
  (str "Exploded " (if is-near "near " "") who))

(function flare who
  (-> (plr who :pos)
     @(map + [0 100 0])
      (fn pos (dl.util.explosion pos "TestGrenade")))
  (str "Fired flare above " who))

(function brrr who
  (if! (plr who :alive?) (return))
  (monologue [
    (str "Airstrike target locked: " who)
    "Coming in hot in 5" "4" "3" "2..."])
  (wait 1)
  (let pos (plr who :pos))
  (let i 0)
  (while (< i 100)
    (let! i inc)
    (wait .01)
    (-> [(rand 10) 0 (rand 10)]
       @(map + [(- (* i 2) 100) 0 0] pos)
        grenade))
  (str who " has been brrr'd."))

(function drone who
  (if! (plr who :alive?) (return))
  (let pos (plr who :pos))
  (monologue [
    "Position locked!" "Drone strike in 4" "3" "2..."])
  (wait 1)
  (let i 0 lim (rand 5 10))
  (while (< i lim)
    (let! i inc)
    (wait .25)
    (-> [(rand -50 50) 30 (rand -50 50)]
       @(map + pos)
        grenade))
  "Drone strike complete.")

(function plant who
  "Not yet implemented.")

(function command sender msg
  (var parts (split " " (lower-case msg))
       [_ b c d] parts
       d (3 parts))
(print parts (3 parts) d)
  (match parts
    ["cmds"]          cmds
    ["players"]       (players)
    ["heal"]          (heal sender)
    ["heal" _]        (heal (n. b))
    ["team" _]        (team sender b)
    ["team"]          (str sender " is " (plr sender :team))
    ["tp" _ "here"]   (teleport (n. b) sender)
    ["tp" _ "to" _]   (teleport (n. b) (n. d))
    ["tp" "to" _]     (teleport sender (n. c))
    ["boom" "near" _] (boom (n. c) true)
    ["boom" _]        (boom (n. b) false)
    ["flare"]         (flare sender)
    ["flare" _]       (flare (n. b))
    ["brrr" _]        (brrr (n. b))
    ["drone"]         (drone sender)
    ["drone" _]       (drone (n. b))
    ["plant"]         (plant (n. b))
    :not-a-command))

(function fmessage m (print m) (dl.util.fmessage m))

(function on-message sender _ msg
  (let result (command sender msg))
(print result)
  (when (!= result :not-a-command)
    (fmessage
      (if (starts? "(" msg)
        (catch (eval msg) errors)
        (or result "Didn't work, maybe player is dead.")))))

(dl.events.on_chat_message.kill)
(dl.events.on_chat_message.connect on-message)
(dl.util.fmessage "Loaded Insitux chatbot! Chat \"cmds\" to see list of available commands.
Note: this is a CHAT bot, you send the commands in the chat.")
